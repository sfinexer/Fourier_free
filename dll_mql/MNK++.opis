#include <stdio.h>
#include <process.h>
#include <math.h>
/*
http://www.alexeypetrov.narod.ru/C/sqr_less_about.html
Чтобы воспользоваться этой программой, нужно запустить скомпилированный исполняемый файл.
В первую очередь программа спросит, откуда ей брать данные для интерполяции.
Создайте в любом текстовом редакторе (но только не в Word-е а, например в notepad-е) файл,
где напишите значения xi, yi, построчно через пробел, приблизительно так:
x0	y0
x1	y1
x2	y2
...
xN	yN

Например:
1 	5.95
2 	20.95
3 	51.9
4 	105
5 	186
6 	301
7 	456.1
8 	657.1

Этот файл необходимо создать в той директории, где лежит программа, иначе она его не найдет.

Программа спросит степень полинома, каким вы хотите аппроксимировать данные.
При этом степень полинома должна быть менее числа заданных точек (в данном случае восьми). Введите, например, 3.
В результате работы программы, она выдаст нечто вроде:

a[0] = 0.996902
a[1] = 1.938750
a[2] = 2.016942
a[3] = 0.999054

Это и есть решение системы уравнений, т.е. набор неизвестных коэффициентов ai. Т.е. по нашим данным был построен аппроксимирующий многочлен

F(x) = 1 + 2x + 2x2 + x3. (я округлил решение до целых чисел)

Коротко опишем, для чего служит такое большое количество подпрограмм и переменных в данной программе:

    a - неизвестные коэффициенты полинома
    b - столбец свободных членов (в правой части уравнений)
    x - координаты, заданные в файле
    y - координаты, заданные в файле
    sums - суммы степеней x,y при неизвестных коэффициентах полинома
    N - число заданных точек в файле
    K - степень аппроксимирующего полинома
    void count_num_lines() - подсчитывает количество точек, где задана функция
    void allocmatrix() - выделяет память для массивов a, b, x, y, sums
    void readmatrix() - прочитывает из файла координаты точек и вычисляет sumsij
    void diagonal() - делает так, чтобы на главной диагонали не было нулей, чтобы не пришлось однажды делить на ноль в процессе приведения системы к треугольному виду
    void printresult() - распечатывает получившийся столбец решений
    void freematrix() - освобождает память, которая была выделена ранее
    void cls() - стирает экран в начале работы программы
    void main() - основная функция из которой последовательно вызываются все вышеперечисленные функции, и проходит процесс приведения системы уравнений к треугольному виду и обратная прогонка.
    */
//extern "C" __declspec(dllexport) void interp(double *x, double *y, double *rezult,int N, int K);
extern "C" __declspec(dllexport) void interp(double *x, double *y, double *rezult, int N, int K);
double *MNK_a, *MNK_b, **MNK_sums;
int MNK_N, MNK_K;
//N - number of data points
//K - polinom power
//K<=N
void freematrix()
{
  //free memory for matrixes
  int i;
  for(i=0; i<MNK_K+1; i++)
    {
      delete MNK_sums[i];
    }
// delete [] MNK_a;
  delete MNK_b;
  delete MNK_sums;
}

void allocmatrix()
{
  //allocate memory for matrixes
  int i,j;
//  MNK_a = new double[MNK_K+1];
  MNK_b = new double[MNK_K+1];
  MNK_sums = new double*[MNK_K+1];
  if( MNK_a==NULL || MNK_sums==NULL)
    {
      printf("\nNot enough memory to allocate. N=%d, K=%d\n", MNK_N, MNK_K);
      exit(-1);
    }
  for(i=0; i<MNK_K+1; i++)
    {
      MNK_sums[i] = new double[MNK_K+1];
      if(MNK_sums[i]==NULL)
        {
          printf("\nNot enough memory to allocate for %d equations.\n", MNK_K+1);
        }
    }
  for(i=0; i<MNK_K+1; i++)
    {
      MNK_a[i]=0;
      MNK_b[i]=0;
      for(j=0; j<MNK_K+1; j++)
        {
          MNK_sums[i][j] = 0;
        }
    }
}

void readmatrix(double *x, double *y)
{
  int i=0,j=0, k=0;
  //init square sums matrix
  for(i=0; i<MNK_K+1; i++)
    {
      for(j=0; j<MNK_K+1; j++)
        {
          MNK_sums[i][j] = 0;
          for(k=0; k<MNK_N; k++)
            {
              MNK_sums[i][j] += pow(x[k], i+j);
            }
        }
    }
  //init free coefficients column
  for(i=0; i<MNK_K+1; i++)
    {
      for(k=0; k<MNK_N; k++)
        {
          MNK_b[i] += pow(x[k], i) * y[k];
        }
    }
}

void printresult()
{
  //print polynom parameters
  int i=0;
  printf("\n");
  for(i=0; i<MNK_K+1; i++)
    {
      printf("a[%d] = %f\n", i, MNK_a[i]);
    }
}
void diagonal()
{
  int i, j, k;
  double temp=0;
  for(i=0; i<MNK_K+1; i++)
    {
      if(MNK_sums[i][i]==0)
        {
          for(j=0; j<MNK_K+1; j++)
            {
              if(j==i)
                {
                  continue;
                }
              if(MNK_sums[j][i] !=0 && MNK_sums[i][j]!=0)
                {
                  for(k=0; k<MNK_K+1; k++)
                    {
                      temp = MNK_sums[j][k];
                      MNK_sums[j][k] = MNK_sums[i][k];
                      MNK_sums[i][k] = temp;
                    }
                  temp = MNK_b[j];
                  MNK_b[j] = MNK_b[i];
                  MNK_b[i] = temp;
                  break;
                }
            }
        }
    }
}
void interp(double *x, double *y, double *rezult, int N, int K)
{
  int i=0,j=0, k=0;
  MNK_N=N;
  MNK_K=K;
  MNK_a=rezult;
  allocmatrix();
  //read data from file
  readmatrix(x, y);
  //check if there are 0 on main diagonal and exchange rows in that case
  diagonal();
  //process rows
  for(k=0; k<MNK_K+1; k++)
    {
      for(i=k+1; i<MNK_K+1; i++)
        {
          if(MNK_sums[k][k]==0)
            {
              printf("\nSolution is not exist.\n");
              return;
            }
          double M = MNK_sums[i][k] / MNK_sums[k][k];
          for(j=k; j<MNK_K+1; j++)
            {
              MNK_sums[i][j] -= M * MNK_sums[k][j];
            }
          MNK_b[i] -= M*MNK_b[k];
        }
    }
  for(i=(MNK_K+1)-1; i>=0; i--)
    {
      double s = 0;
      for(j = i; j<MNK_K+1; j++)
        {
          s = s + MNK_sums[i][j]*MNK_a[j];
        }
      MNK_a[i] = (MNK_b[i] - s) / MNK_sums[i][i];
    }
// printresult();
  rezult=MNK_a;
  freematrix();
}
void inter_vn(double *x, double *y, double *rezult, int N, int K)
{
  int i=0,j=0, k=0;
  MNK_N=N;
  MNK_K=K;
  MNK_a=rezult;
  allocmatrix();
  //read data from file
  readmatrix(x, y);
  //check if there are 0 on main diagonal and exchange rows in that case
  diagonal();
  //process rows
  for(k=0; k<MNK_K+1; k++)
    {
      for(i=k+1; i<MNK_K+1; i++)
        {
          if(MNK_sums[k][k]==0)
            {
              printf("\nSolution is not exist.\n");
              return;
            }
          double M = MNK_sums[i][k] / MNK_sums[k][k];
          for(j=k; j<MNK_K+1; j++)
            {
              MNK_sums[i][j] -= M * MNK_sums[k][j];
            }
          MNK_b[i] -= M*MNK_b[k];
        }
    }
  for(i=(MNK_K+1)-1; i>=0; i--)
    {
      double s = 0;
      for(j = i; j<MNK_K+1; j++)
        {
          s = s + MNK_sums[i][j]*MNK_a[j];
        }
      MNK_a[i] = (MNK_b[i] - s) / MNK_sums[i][i];
    }
// printresult();
  rezult=MNK_a;
  freematrix();
}
